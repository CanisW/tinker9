#include "chgpen.h"
#include "md.h"
#include "mod.chgpen.h"
#include <map>
#include <tinker/detail/chgpen.hh>
#include <tinker/detail/couple.hh>
#include <tinker/detail/mplpot.hh>
#include <tinker/detail/polgrp.hh>
#include <tinker/detail/polpot.hh>
#include <tinker/detail/sizes.hh>


namespace tinker {
void chgpen_data(rc_op op)
{
   if (op & rc_dealloc) {
      ndwexclude = 0;
      darray::deallocate(dwexclude, dwexclude_scale);
      ndexclude = 0;
      darray::deallocate(dexclude, dexclude_scale);
      nwexclude = 0;
      darray::deallocate(wexclude, wexclude_scale);

      darray::deallocate(pcore, pval, palpha);
   }

   if (op & rc_alloc) {
      // see also attach.h
      const int maxn15 = 27 * sizes::maxval;
      const int maxp11 = polgrp::maxp11;
      const int maxp12 = polgrp::maxp12;
      const int maxp13 = polgrp::maxp13;
      const int maxp14 = polgrp::maxp14;


      struct dw_scale
      {
         real d, w;
      };

      auto insert_dw = [](std::map<std::pair<int, int>, dw_scale>& m, int i,
                          int k, real val, char ch) {
         std::pair<int, int> key;
         key.first = i;
         key.second = k;
         auto it = m.find(key);
         if (it == m.end()) {
            dw_scale dw;
            dw.d = 0;
            dw.w = 0;
            if (ch == 'd')
               dw.d = val;
            else if (ch == 'w')
               dw.w = val;
            m[key] = dw;
         } else {
            if (ch == 'd')
               it->second.d = val;
            else if (ch == 'w')
               it->second.w = val;
         }
      };

      std::map<std::pair<int, int>, dw_scale> ik_dw;

      std::vector<int> exclik;
      std::vector<real> excls;

      d1scale = polpot::d1scale;
      d2scale = polpot::d2scale;
      d3scale = polpot::d3scale;
      d4scale = polpot::d4scale;

      exclik.clear();
      excls.clear();
      for (int i = 0; i < n; ++i) {
         int nn, bask;

         if (d1scale != 1) {
            nn = polgrp::np11[i];
            bask = i * maxp11;
            for (int j = 0; j < nn; ++j) {
               int k = polgrp::ip11[bask + j] - 1;
               if (k > i) {
                  insert_dw(ik_dw, i, k, d1scale - 1, 'd');
                  exclik.push_back(i);
                  exclik.push_back(k);
                  excls.push_back(d1scale - 1);
               }
            }
         }

         if (d2scale != 1) {
            nn = polgrp::np12[i];
            bask = i * maxp12;
            for (int j = 0; j < nn; ++j) {
               int k = polgrp::ip12[bask + j] - 1;
               if (k > i) {
                  insert_dw(ik_dw, i, k, d2scale - 1, 'd');
                  exclik.push_back(i);
                  exclik.push_back(k);
                  excls.push_back(d2scale - 1);
               }
            }
         }

         if (d3scale != 1) {
            nn = polgrp::np13[i];
            bask = i * maxp13;
            for (int j = 0; j < nn; ++j) {
               int k = polgrp::ip13[bask + j] - 1;
               if (k > i) {
                  insert_dw(ik_dw, i, k, d3scale - 1, 'd');
                  exclik.push_back(i);
                  exclik.push_back(k);
                  excls.push_back(d3scale - 1);
               }
            }
         }

         if (d4scale != 1) {
            nn = polgrp::np14[i];
            bask = i * maxp14;
            for (int j = 0; j < nn; ++j) {
               int k = polgrp::ip14[bask + j] - 1;
               if (k > i) {
                  insert_dw(ik_dw, i, k, d4scale - 1, 'd');
                  exclik.push_back(i);
                  exclik.push_back(k);
                  excls.push_back(d4scale - 1);
               }
            }
         }
      }

      ndexclude = excls.size();
      darray::allocate(ndexclude, &dexclude, &dexclude_scale);
      darray::copyin(WAIT_NEW_Q, ndexclude, dexclude, exclik.data());
      darray::copyin(WAIT_NEW_Q, ndexclude, dexclude_scale, excls.data());

      w2scale = polpot::w2scale;
      w3scale = polpot::w3scale;
      w4scale = polpot::w4scale;
      w5scale = polpot::w5scale;

      exclik.clear();
      excls.clear();

      for (int i = 0; i < n; ++i) {
         int nn, bask;

         if (w2scale != 1) {
            nn = couple::n12[i];
            bask = i * maxp12;
            for (int j = 0; j < nn; ++j) {
               int k = couple::i12[i][bask + j] - 1;
               if (k > i) {
                  insert_dw(ik_dw, i, k, w2scale - 1, 'w');
                  exclik.push_back(i);
                  exclik.push_back(k);
                  excls.push_back(w2scale - 1);
               }
            }
         }

         if (w3scale != 1) {
            nn = couple::n13[i];
            bask = i * maxp13;
            for (int j = 0; j < nn; ++j) {
               int k = couple::i13[bask + j] - 1;
               if (k > i) {
                  insert_dw(ik_dw, i, k, w3scale - 1, 'w');
                  exclik.push_back(i);
                  exclik.push_back(k);
                  excls.push_back(w3scale - 1);
               }
            }
         }

         if (w4scale != 1) {
            nn = couple::n14[i];
            bask = i * maxp14;
            for (int j = 0; j < nn; ++j) {
               int k = couple::i14[bask + j] - 1;
               if (k > i) {
                  insert_dw(ik_dw, i, k, w4scale - 1, 'w');
                  exclik.push_back(i);
                  exclik.push_back(k);
                  excls.push_back(w4scale - 1);
               }
            }
         }

         if (w5scale != 1) {
            nn = couple::n15[i];
            bask = i * maxn15;
            for (int j = 0; j < nn; ++j) {
               int k = couple::i15[bask + j] - 1;
               if (k > i) {
                  insert_dw(ik_dw, i, k, w5scale - 1, 'w');
                  exclik.push_back(i);
                  exclik.push_back(k);
                  excls.push_back(w5scale - 1);
               }
            }
         }
      }

      nwexclude = excls.size();
      darray::allocate(nwexclude, &wexclude, &wexclude_scale);
      darray::copyin(WAIT_NEW_Q, nwexclude, wexclude, exclik.data());
      darray::copyin(WAIT_NEW_Q, nwexclude, wexclude_scale, excls.data());


      std::vector<int> dw_ik_vec;
      std::vector<real> dw_sc_vec;
      for (auto& it : ik_dw) {
         dw_ik_vec.push_back(it.first.first);
         dw_ik_vec.push_back(it.first.second);
         dw_sc_vec.push_back(it.second.d);
         dw_sc_vec.push_back(it.second.w);
      }
      ndwexclude = ik_dw.size();
      darray::allocate(ndwexclude, &dwexclude, &dwexclude_scale);
      darray::copyin(WAIT_NEW_Q, ndwexclude, dwexclude, dw_ik_vec.data());
      darray::copyin(WAIT_NEW_Q, ndwexclude, dwexclude_scale, dw_sc_vec.data());

      darray::allocate(n, &pcore, &pval, &palpha);
   }

   if (op & rc_init) {
      darray::copyin(WAIT_NEW_Q, n, pcore, chgpen::pcore);
      darray::copyin(WAIT_NEW_Q, n, pval, chgpen::pval);
      darray::copyin(WAIT_NEW_Q, n, palpha, chgpen::palpha);
   }
}
}
